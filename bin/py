#!/usr/bin/env python3

import argparse
import fileinput
import sys
import re
import json
from types import SimpleNamespace


def get_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Python but for Perl/Ruby-style oneliners"
    )
    parser.add_argument(
        "files",
        metavar="FILE",
        nargs="*",
        default="-",
        help="files to read, defaulting to stdin if empty",
    )
    parser.add_argument(
        "-e",
        metavar="program",
        help="one line of program (TODO: several -e's allowed, omit programfile)",
    )
    parser.add_argument(
        "-a",
        action="store_true",
        help="autosplit mode with -n or -p (splits `_` into `F`)",
    )
    parser.add_argument(
        "-F",
        metavar="pattern",
        default=r"\s+",
        help="split() pattern for autosplit (-a)",
    )
    parser.add_argument(
        "-n",
        action="store_true",
        help="assume 'for _ in fileinput.input: ...' loop around your script",
    )
    parser.add_argument(
        "-p",
        action="store_true",
        help="assume loop like -n but print line also, like sed",
    )
    parser.add_argument(
        "-l",
        default=True,
        action="store_true",
        help="enable line ending processing (TODO: always true)",
    )
    parser.add_argument(
        "-j",
        action="store_true",
        help="parse input as JSON into a SimpleNamespace",
    )
    parser.add_argument(
        "-J",
        action="store_true",
        help="like -j, but also serialize output as JSON",
    )
    return parser.parse_args()


def jprint(input):
    print(json.dumps(input, default=lambda x: x.__dict__))


def main():
    args = get_args()

    if args.a:
        pattern = re.compile(args.F)

    if args.n or args.p:
        for _ in fileinput.input(files=args.files):
            if args.l:
                _ = _.rstrip("\n")
            if args.a:
                F = pattern.split(_)
            if args.n:
                exec(args.e)
            else:  # args.p
                exec(f"print({args.e})")
    else:
        # TODO: _ should still be populated, and -F, -a should still work
        # TODO: ; does not work, should be supported by `exec`
        _ = "".join(fileinput.input(files=args.files))
        if args.j or args.J:
            _ = json.loads(_, object_hook=lambda x: SimpleNamespace(**x))
        if args.J:
            exec(f"jprint({args.e})")
        else:
            exec(args.e)


if __name__ == "__main__":
    main()
